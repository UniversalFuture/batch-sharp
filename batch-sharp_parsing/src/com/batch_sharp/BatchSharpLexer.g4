lexer grammar BatchSharpLexer;

WS: (' ' | '\t' | NEWLINE)+ -> skip;
fragment NEWLINE : '\r'|'\n'|'\r\n';

PLUS: '+';
MINUS: '-';
TO_THE_POWER_OF: '^';
DIVIDED_BY: '/';
TIMES: '*';

ARROBA: '@';
BACKTICK: '`';
BOOL_AND: '&&';
BOOL_EQUALS: '==';
BOOL_OR: '||';
CATCH: 'catch';
COMMA: ',';
CONST: 'const';
DASH: '-';
DECIMAL: [0-9]+ '.' [0-9]+;
DIR: 'dir';
DOLLAR: '$';
DOT: '.';
ELSE: 'else';
EQUALS: '=';
FILE: 'file';
FOR: 'for';
GE: '>=';
GT: '>';
H: 'h';
HASH: '#';
IF: 'if';
IN: 'in';
INLINE: 'inline';
INLINEBACKTICK: BACKTICK .+? BACKTICK;
INLINESTMT: BACKTICK BACKTICK .+? BACKTICK BACKTICK;
LBRACKET: '{';
LPAREN: '(';
LSQUARE: '[';
LE: '<=';
LT: '<';
NOT_EQUALS: '!=';
NUMBER: [0-9]+ | DECIMAL;
NUMERAL: [0-9];
PERCENT: '%';
RBRACKET: '}';
RECURSIVE: 'recursive';
RETURN: 'return';
RPAREN: ')';
RSQUARE: ']';
SEMI: ';';
SLASH: '/';
SINGLE_LINE_COMMENT : ('//' Input_character*) -> channel(HIDDEN);
fragment Input_character: ~([\u000D\u000A\u0085\u2028\u2029]);
STRING : '"' ~('\r' | '\n' | '"')* '"' ;
TRY: 'try';
TYPE_ARRAY: 'array';
TYPE_INT: 'int';
TYPE_STRING: 'string';
UNDERSCORE: '_';
ZERO_X: '0x';

ID: [a-zA-Z] [a-zA-Z_-0-9]*;